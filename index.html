<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3A Console - ESP32 Sensor Device Status</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      :root {
        --primary-color: #3498db;
        --success-color: #2ecc71;
        --warning-color: #f39c12;
        --danger-color: #e74c3c;
        --info-color: #9b59b6;
      }
      body {
        padding-bottom: 2rem;
        background-color: #f8f9fa;
      }
      .navbar-brand {
        font-weight: bold;
        color: var(--primary-color) !important;
      }
      .card {
        border-radius: 0.5rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s;
        margin-bottom: 1.5rem;
      }
      .card:hover {
        transform: translateY(-5px);
      }
      .card-header {
        border-radius: 0.5rem 0.5rem 0 0 !important;
        font-weight: bold;
      }
      .status-badge {
        font-size: 0.85rem;
        padding: 0.35rem 0.65rem;
        border-radius: 1rem;
      }
      .update-reason {
        font-size: 0.85rem;
        font-style: italic;
        margin-top: 0.5rem;
        color: #666;
      }
      .up-to-date {
        background-color: var(--success-color);
        color: white;
      }
      .needs-update {
        background-color: var(--warning-color);
        color: white;
      }
      .patch-available {
        background-color: var(--info-color);
        color: white;
      }
      .unknown {
        background-color: var(--danger-color);
        color: white;
      }

      .version-tag {
        background-color: var(--primary-color);
        color: white;
        border-radius: 0.25rem;
        padding: 0.2rem 0.5rem;
        font-size: 0.85rem;
        font-family: monospace;
      }

      .component-tag {
        background-color: #6c757d;
        color: white;
        border-radius: 0.25rem;
        padding: 0.1rem 0.4rem;
        font-size: 0.75rem;
        margin-right: 0.25rem;
        margin-bottom: 0.25rem;
        display: inline-block;
      }
      .component-tag.modbus {
        background-color: #007bff;
      }
      .component-tag.onewire {
        background-color: #28a745;
      }
      .component-tag.digital {
        background-color: #6610f2;
      }
      .component-tag.analog {
        background-color: #fd7e14;
      }
      .component-tag.i2c {
        background-color: #20c997;
      }
      .component-tag.virtual {
        background-color: #9c27b0;
      }
      .component-tag.core {
        background-color: #343a40;
      }

      .timeline {
        position: relative;
        max-width: 1200px;
        margin: 0 auto;
        padding: 1rem 0;
      }
      .timeline::after {
        content: "";
        position: absolute;
        width: 2px;
        background-color: var(--primary-color);
        top: 0;
        bottom: 0;
        left: 50%;
        margin-left: -1px;
      }
      .timeline-container {
        padding: 10px 40px;
        position: relative;
        background-color: inherit;
        width: 50%;
      }
      .timeline-container.left {
        left: 0;
      }
      .timeline-container.right {
        left: 50%;
      }
      .timeline-container::after {
        content: "";
        position: absolute;
        width: 16px;
        height: 16px;
        right: -8px;
        background-color: white;
        border: 2px solid var(--primary-color);
        top: 15px;
        border-radius: 50%;
        z-index: 1;
      }
      .timeline-container.right::after {
        left: -8px;
      }
      .timeline-content {
        padding: 1rem;
        background-color: white;
        position: relative;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .timeline-date {
        font-weight: bold;
        color: var(--primary-color);
      }
      .last-update {
        font-size: 0.85rem;
        color: #6c757d;
        text-align: right;
        margin-top: 2rem;
      }

      @media (max-width: 768px) {
        .timeline::after {
          left: 31px;
        }
        .timeline-container {
          width: 100%;
          padding-left: 70px;
          padding-right: 25px;
        }
        .timeline-container.right {
          left: 0%;
        }
        .timeline-container.left::after,
        .timeline-container.right::after {
          left: 23px;
        }
      }

      /* Search and filter */
      .filter-section {
        background-color: white;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 1.5rem;
      }
      .filter-badge {
        cursor: pointer;
        margin-right: 0.5rem;
      }
      .component-filter {
        cursor: pointer;
        margin: 0.25rem;
      }

      /* Version info tooltip */
      .version-info {
        margin-top: 10px;
        font-size: 0.8rem;
        color: #6c757d;
        font-style: italic;
      }

      /* Version changes section - UPDATED FOR COMPACT DISPLAY */
      .version-changes {
        margin-top: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .version-item {
        padding: 0.5rem 1rem;
        border-left: 3px solid var(--primary-color);
        margin-bottom: 0.5rem;
        background-color: rgba(52, 152, 219, 0.05);
        flex: 1 1 30%;
        min-width: 250px;
      }
      .version-title {
        font-weight: bold;
        color: var(--primary-color);
      }
      .version-date {
        font-size: 0.85rem;
        color: #6c757d;
        margin-left: 0.5rem;
      }
      .version-description {
        margin-top: 0.25rem;
        font-size: 0.9rem;
      }

      /* Device List Styles */
      .device-list-header {
        background-color: #f5f5f5;
        padding: 10px;
        border-radius: 5px 5px 0 0;
        font-weight: bold;
      }

      .device-list-item {
        padding: 10px;
        border-bottom: 1px solid #eee;
      }

      .device-list-item:hover {
        background-color: #f9f9f9;
      }

      .needs-update {
        background-color: rgba(255, 200, 200, 0.2);
      }

      .patch-available {
        background-color: rgba(255, 240, 200, 0.2);
      }

      .up-to-date {
        background-color: rgba(200, 255, 200, 0.2);
      }

      /* Sorting Controls */
      .sorting-controls {
        margin: 20px 0;
      }

      .sort-btn.active {
        background-color: #0d6efd;
        color: white;
      }

      /* Timeline Styles */
      .timeline-month {
        margin-bottom: 30px;
      }

      .timeline-month h3 {
        color: #555;
        border-bottom: 1px solid #ddd;
        padding-bottom: 5px;
      }

      .timeline-events {
        list-style-type: none;
        padding-left: 15px;
        position: relative;
      }

      .timeline-events::before {
        content: "";
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 2px;
        background-color: #ddd;
      }

      .timeline-event {
        position: relative;
        padding: 10px 0 10px 20px;
        margin-bottom: 10px;
      }

      .timeline-event::before {
        content: "";
        position: absolute;
        left: -4px;
        top: 14px;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background-color: #0d6efd;
      }

      .event-initial_deployment::before {
        background-color: #28a745;
      }

      .event-update_deployment::before {
        background-color: #007bff;
      }

      .event-previous_deployment::before {
        background-color: #6c757d;
      }

      .event-date {
        font-weight: bold;
        margin-right: 10px;
      }

      .event-device {
        color: #555;
        margin-right: 10px;
      }

      .event-description {
        display: inline-block;
      }

      /* View toggle buttons */
      .view-toggle {
        margin-bottom: 1rem;
      }
    </style>
  </head>
  <body>
    <nav class="navbar navbar-expand-lg navbar-light bg-white mb-4 shadow-sm">
      <div class="container">
        <a class="navbar-brand" href="#">
          <i class="bi bi-cpu"></i> 3A Console - ESP32 Sensor Status
        </a>
        <button
          class="navbar-toggler"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarNav"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav ms-auto">
            <li class="nav-item">
              <a class="nav-link" href="#overview"
                ><i class="bi bi-house"></i> Overview</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#devices"
                ><i class="bi bi-grid"></i> Devices</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#versions"
                ><i class="bi bi-list-check"></i> Version History</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link" href="#timeline"
                ><i class="bi bi-calendar"></i> Timeline</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container" id="overview">
      <div class="row mb-4">
        <div class="col-md-6">
          <div class="card">
            <div class="card-header bg-primary text-white">
              <i class="bi bi-info-circle"></i> Template Information
            </div>
            <div class="card-body">
              <h5 class="card-title">
                Latest Version:
                <span id="latest-version" class="version-tag"></span>
              </h5>
              <p class="card-text">
                <i class="bi bi-github"></i> Repository:
                <span id="repo-name"></span>
              </p>
              <p class="card-text">
                <i class="bi bi-clock"></i> Last commit:
                <span id="last-commit-date"></span>
              </p>
            </div>
          </div>
        </div>
        <div class="col-md-6">
          <div class="card">
            <div class="card-header bg-info text-white">
              <i class="bi bi-pie-chart"></i> Status Overview
            </div>
            <div class="card-body">
              <canvas id="status-chart" height="200"></canvas>
            </div>
          </div>
        </div>
      </div>

      <section id="versions" class="mb-5">
        <h2 class="mb-3"><i class="bi bi-list-check"></i> Version History</h2>
        <div class="card">
          <div class="card-body">
            <div class="version-changes" id="version-changes-list">
              <!-- Version changes will be populated here -->
              <div class="text-center py-2">
                <div class="spinner-border text-primary" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="devices">
        <h2 class="mb-3"><i class="bi bi-grid"></i> Device Status</h2>

        <div class="filter-section mb-4">
          <div class="row align-items-center mb-3">
            <div class="col-md-8">
              <div class="input-group">
                <span class="input-group-text"
                  ><i class="bi bi-search"></i
                ></span>
                <input
                  type="text"
                  id="device-search"
                  class="form-control"
                  placeholder="Search devices..."
                />
              </div>
            </div>
            <div class="col-md-4">
              <div class="d-flex justify-content-end">
                <span
                  class="filter-badge badge bg-success"
                  data-filter="up-to-date"
                  >Up to date</span
                >
                <span
                  class="filter-badge badge"
                  style="background-color: var(--info-color); color: white"
                  data-filter="patch-available"
                  >Patch available</span
                >
                <span
                  class="filter-badge badge bg-warning text-dark"
                  data-filter="needs-update"
                  >Needs update</span
                >
                <span class="filter-badge badge bg-danger" data-filter="unknown"
                  >Unknown</span
                >
              </div>
            </div>
          </div>

          <div class="row">
            <div class="col-12">
              <p class="mb-1"><small>Filter by component:</small></p>
              <div id="component-filters">
                <!-- Component filters will be added here -->
              </div>
            </div>
          </div>
        </div>

        <!-- View Toggle Buttons -->
        <div class="view-toggle btn-group mb-3" role="group">
          <button
            id="card-view-btn"
            class="btn btn-sm btn-outline-primary active"
          >
            Card View
          </button>
          <button id="list-view-btn" class="btn btn-sm btn-outline-primary">
            List View
          </button>
        </div>

        <!-- Device Sorting Controls (new) -->
        <div class="sorting-controls mb-3">
          <label>Sort devices by: </label>
          <div class="btn-group" role="group">
            <button
              id="sort-by-date"
              class="btn btn-sm btn-outline-primary sort-btn active"
            >
              Date Updated
            </button>
            <button
              id="sort-by-name"
              class="btn btn-sm btn-outline-primary sort-btn"
            >
              Name
            </button>
            <button
              id="sort-by-status"
              class="btn btn-sm btn-outline-primary sort-btn"
            >
              Status
            </button>
            <button
              id="sort-by-location"
              class="btn btn-sm btn-outline-primary sort-btn"
            >
              Location
            </button>
          </div>
        </div>

        <!-- Device List Container (new) -->
        <div id="device-list" class="mb-5" style="display: none"></div>

        <!-- Original Device Cards Container -->
        <div class="row" id="device-cards">
          <!-- Device cards will be populated here -->
          <div class="col-12 text-center py-5">
            <div class="spinner-border text-primary" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Loading device data...</p>
          </div>
        </div>
      </section>

      <section id="timeline" class="mt-5">
        <h2 class="mb-4"><i class="bi bi-calendar"></i> Deployment Timeline</h2>
        <!-- New Timeline Container -->
        <div id="timeline-container" class="mt-3"></div>
      </section>

      <p class="last-update">
        Dashboard updated: <span id="last-updated"></span>
      </p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
      function addTimelineStyles() {
        const styleEl = document.createElement("style");
        styleEl.innerHTML = `
.timeline-month {
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.timeline-month h3 {
  margin: 0;
  padding: 10px 15px;
  font-size: 1.2rem;
}

.date-header {
  font-size: 1rem;
}

.list-group-item.event-initial_deployment {
  background-color: rgba(40, 167, 69, 0.05);
}

.list-group-item.event-update_deployment {
  background-color: rgba(0, 123, 255, 0.05);
}

.list-group-item.event-previous_deployment {
  background-color: rgba(108, 117, 125, 0.05);
}

.list-group-item.event-deployment {
  background-color: rgba(40, 167, 69, 0.05);
}
`;

        document.head.appendChild(styleEl);
      }

      // Main initialization function
      document.addEventListener("DOMContentLoaded", () => {
        addTimelineStyles();
        initDashboard();
      });

      // Initialize the dashboard
      async function initDashboard() {
        try {
          // Fetch device status data
          const response = await fetch("data/device-status.json");
          const dashboardData = await response.json();

          // Update header information
          document.getElementById("latest-version").textContent =
            dashboardData.latest_version;
          document.getElementById("repo-name").textContent =
            dashboardData.repo_name;
          document.getElementById("last-commit-date").textContent =
            dashboardData.last_commit_date;
          document.getElementById("last-updated").textContent = formatDate(
            dashboardData.last_updated
          );

          // Status counters for chart
          let statusCounts = {
            "Up to date": 0,
            "Patch available": 0,
            "Needs update": 0,
            Unknown: 0,
          };

          // Process devices to count statuses
          dashboardData.devices.forEach((device) => {
            // Calculate status
            const calculatedStatus = getUpdateStatus(
              device.version,
              dashboardData.latest_version,
              device.components,
              device.updateReason
            );

            // Count statuses for chart
            statusCounts[calculatedStatus]++;

            // Add calculated status to device
            device.calculatedStatus = calculatedStatus;
          });

          // Create version history section
          createVersionHistory(dashboardData.version_changes);

          // Create component filters
          createComponentFilters(dashboardData.devices);

          // Create device list (new)
          renderDeviceList(dashboardData.devices, "date");

          // Create original card view
          createDeviceCards(
            dashboardData.devices,
            dashboardData.latest_version
          );

          // Create timeline (new)
          if (dashboardData.timeline_events) {
            renderTimeline(dashboardData.timeline_events);
          } else {
            // Use old timeline if timeline_events not available
            createOriginalTimeline(dashboardData.devices);
          }

          // Create status chart
          createStatusChart(statusCounts);

          // Set up event listeners
          setupEventListeners(dashboardData);
        } catch (error) {
          console.error("Error initializing dashboard:", error);
          document.getElementById("device-cards").innerHTML = `
            <div class="col-12 text-center py-5">
              <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i> Error loading device status data.
                Please check if data/device-status.json exists.
              </div>
            </div>
          `;
        }
      }

      // Format date for display
      function formatDate(dateStr) {
        if (!dateStr || dateStr === "Never" || dateStr === "N/A")
          return dateStr;
        const date = new Date(dateStr);
        return date.toLocaleDateString() + " " + date.toLocaleTimeString();
      }

      // Function to check device update status based on version comparison
      function getUpdateStatus(
        deviceVersion,
        latestVersion,
        deviceComponents,
        updateReason
      ) {
        // If no device version is available, it needs an update
        if (!deviceVersion) return "Unknown";

        // Parse version strings (assuming format vX.Y.Z)
        const parseVersion = (version) => {
          const match = version.match(/v?(\d+)\.(\d+)\.(\d+)/);
          if (!match) return null;
          return {
            major: parseInt(match[1], 10),
            minor: parseInt(match[2], 10),
            patch: parseInt(match[3], 10),
          };
        };

        const deviceVer = parseVersion(deviceVersion);
        const latestVer = parseVersion(latestVersion);

        // If parsing failed, conservatively assume update is needed
        if (!deviceVer || !latestVer) return "Unknown";

        // Check version differences
        if (deviceVer.major < latestVer.major) {
          return "Needs update"; // Major version behind - critical update
        } else if (
          deviceVer.major === latestVer.major &&
          deviceVer.minor < latestVer.minor
        ) {
          return "Needs update"; // Minor version behind - important functionality
        } else if (
          deviceVer.major === latestVer.major &&
          deviceVer.minor === latestVer.minor &&
          deviceVer.patch < latestVer.patch
        ) {
          // For patch version, always show "Patch available"
          // This is a patch-level update, which should be indicated regardless of component
          return "Patch available";
        } else {
          return "Up to date"; // Completely up to date
        }
      }

      // Generate component tags HTML
      function generateComponentTags(components) {
        if (
          !components ||
          !Array.isArray(components) ||
          components.length === 0
        ) {
          return '<span class="text-muted">None specified</span>';
        }

        return components
          .map(
            (component) =>
              `<span class="component-tag ${component.toLowerCase()}">${component}</span>`
          )
          .join("");
      }

      // Create version history section
      function createVersionHistory(versionChanges) {
        if (!versionChanges || !Array.isArray(versionChanges)) return;

        const container = document.getElementById("version-changes-list");
        container.innerHTML = "";

        // Only show the most recent 9 versions to keep it compact
        const recentChanges = versionChanges.slice(0, 9);

        recentChanges.forEach((version) => {
          const versionItem = document.createElement("div");
          versionItem.className = "version-item";

          versionItem.innerHTML = `
            <div>
              <span class="version-title">${version.version}</span>
              <span class="version-date">${version.date}</span>
            </div>
            <div class="version-components my-1">
              ${generateComponentTags(version.components)}
            </div>
            <div class="version-description">
              ${version.description}
            </div>
          `;

          container.appendChild(versionItem);
        });

        // Add a "Show more" button if there are more versions
        if (versionChanges.length > 9) {
          const showMoreBtn = document.createElement("button");
          showMoreBtn.className = "btn btn-sm btn-outline-primary mt-2";
          showMoreBtn.textContent = `Show ${
            versionChanges.length - 9
          } more versions`;
          showMoreBtn.onclick = function () {
            createFullVersionHistory(versionChanges);
            this.style.display = "none";
          };

          container.appendChild(showMoreBtn);
        }

        if (versionChanges.length === 0) {
          container.innerHTML =
            '<div class="text-center py-3">No version history available</div>';
        }
      }

      // Show all version history when "Show more" is clicked
      function createFullVersionHistory(versionChanges) {
        const container = document.getElementById("version-changes-list");

        // Keep the first 9 items that are already displayed
        const existingItems = container.querySelectorAll(".version-item");
        const showMoreBtn = container.querySelector("button");

        if (showMoreBtn) {
          container.removeChild(showMoreBtn);
        }

        // Add the remaining versions
        for (let i = 9; i < versionChanges.length; i++) {
          const version = versionChanges[i];
          const versionItem = document.createElement("div");
          versionItem.className = "version-item";

          versionItem.innerHTML = `
            <div>
              <span class="version-title">${version.version}</span>
              <span class="version-date">${version.date}</span>
            </div>
            <div class="version-components my-1">
              ${generateComponentTags(version.components)}
            </div>
            <div class="version-description">
              ${version.description}
            </div>
          `;

          container.appendChild(versionItem);
        }
      }

      // Create component filters
      function createComponentFilters(devices) {
        const componentsSet = new Set();

        // Collect all unique components
        devices.forEach((device) => {
          if (device.components && Array.isArray(device.components)) {
            device.components.forEach((comp) => componentsSet.add(comp));
          }
        });

        // Create filter badges
        const filterContainer = document.getElementById("component-filters");
        filterContainer.innerHTML = "";

        const componentsList = Array.from(componentsSet).sort();
        componentsList.forEach((comp) => {
          const badge = document.createElement("span");
          badge.className = `component-filter component-tag ${comp.toLowerCase()}`;
          badge.textContent = comp;
          badge.dataset.component = comp.toLowerCase();

          badge.addEventListener("click", function () {
            const isActive = this.classList.contains("active");

            // Reset all filters
            document.querySelectorAll(".component-filter").forEach((b) => {
              b.classList.remove("active");
              b.style.opacity = "1";
            });

            if (!isActive) {
              // Activate this filter
              this.classList.add("active");

              // Dim other filters
              document
                .querySelectorAll(".component-filter:not(.active)")
                .forEach((b) => {
                  b.style.opacity = "0.5";
                });

              // Filter devices
              filterDevicesByComponent(comp.toLowerCase());
            } else {
              // Show all devices
              const deviceItems = document.querySelectorAll(".device-item");
              deviceItems.forEach((item) => {
                item.style.display = "block";
              });

              // Show all devices in list view too
              document.querySelectorAll(".device-list-item").forEach((item) => {
                item.style.display = "";
              });
            }
          });

          filterContainer.appendChild(badge);
        });

        if (componentsList.length === 0) {
          filterContainer.innerHTML =
            '<div class="text-muted">No components defined</div>';
        }
      }

      // Sort function mapping
      const sortFunctions = {
        // Sort by deployment date (newest first)
        date: (a, b) => {
          if (!a.last_deployed) return 1;
          if (!b.last_deployed) return -1;
          return new Date(b.last_deployed) - new Date(a.last_deployed);
        },

        // Sort by name (alphabetical)
        name: (a, b) => a.name.localeCompare(b.name),

        // Sort by status (priority order)
        status: (a, b) => {
          const statusPriority = {
            "Needs update": 0,
            "Patch available": 1,
            "Up to date": 2,
            "Never deployed": 3,
            Unknown: 4,
          };
          const statusA = a.calculatedStatus || a.status;
          const statusB = b.calculatedStatus || b.status;
          return statusPriority[statusA] - statusPriority[statusB];
        },

        // Sort by location
        location: (a, b) => {
          if (!a.location) return 1;
          if (!b.location) return -1;
          return a.location.localeCompare(b.location);
        },
      };

      // Render the device list with sorting
      function renderDeviceList(devices, sortBy = "date") {
        const container = document.getElementById("device-list");
        if (!container) return;

        // Clone and sort the devices array
        const sortedDevices = [...devices].sort(sortFunctions[sortBy]);

        // Clear the container
        container.innerHTML = "";

        // Add header row
        const headerRow = document.createElement("div");
        headerRow.className = "device-list-header row";
        headerRow.innerHTML = `
          <div class="col-md-3 fw-bold">Device Name</div>
          <div class="col-md-2 fw-bold">Version</div>
          <div class="col-md-2 fw-bold">Status</div>
          <div class="col-md-3 fw-bold">Location</div>
          <div class="col-md-2 fw-bold">Last Updated</div>
        `;
        container.appendChild(headerRow);

        // Add device rows
        sortedDevices.forEach((device) => {
          const row = document.createElement("div");
          row.className = "device-list-item row";

          // Calculate status if not already set
          const status = device.calculatedStatus || device.status || "Unknown";

          // Add status-based class
          if (status === "Needs update") {
            row.classList.add("needs-update");
          } else if (status === "Patch available") {
            row.classList.add("patch-available");
          } else if (status === "Up to date") {
            row.classList.add("up-to-date");
          }

          const date = device.last_deployed
            ? new Date(device.last_deployed).toLocaleDateString()
            : "Never";

          row.innerHTML = `
            <div class="col-md-3">${device.name}</div>
            <div class="col-md-2">${
              device.version || device.template_version || "-"
            }</div>
            <div class="col-md-2">${status}</div>
            <div class="col-md-3">${device.location || "-"}</div>
            <div class="col-md-2">${date}</div>
          `;

          container.appendChild(row);
        });

        // Update active sort button
        document.querySelectorAll(".sort-btn").forEach((btn) => {
          btn.classList.remove("active");
        });
        document.getElementById(`sort-by-${sortBy}`).classList.add("active");
      }

      // Create device cards (original function)
      function createDeviceCards(devices, latestVersion) {
        const deviceCardsContainer = document.getElementById("device-cards");
        deviceCardsContainer.innerHTML = ""; // Clear loading spinner

        // Create device cards
        devices.forEach((device) => {
          // Get status (either from calculated status or from device.status)
          const status = device.calculatedStatus || device.status || "Unknown";

          // Create card
          const col = document.createElement("div");
          col.className = "col-md-6 col-lg-4 device-item";
          col.dataset.status = status.replace(/\s+/g, "-").toLowerCase();

          // Add component data attributes for filtering
          if (device.components && Array.isArray(device.components)) {
            device.components.forEach((comp) => {
              col.dataset[comp.toLowerCase()] = "true";
            });
          }

          let statusClass = "";
          if (status === "Up to date") statusClass = "up-to-date";
          else if (status === "Patch available")
            statusClass = "patch-available";
          else if (status === "Needs update") statusClass = "needs-update";
          else statusClass = "unknown";

          let cardHtml = `
            <div class="card">
              <div class="card-header bg-light">
                <div class="d-flex justify-content-between align-items-center">
                  <span>${device.name}</span>
                  <span class="status-badge ${statusClass}">${status}</span>
                </div>
              </div>
              <div class="card-body">
                <div class="mb-3">
                  <small class="text-muted">Template Version:</small>
                  <div><span class="version-tag">${
                    device.template_version || device.version || "Unknown"
                  }</span></div>
                </div>
                <div class="mb-3">
                  <small class="text-muted">Components:</small>
                  <div>${generateComponentTags(device.components)}</div>
                </div>`;

          // Add update reason if available
          if (device.updateReason) {
            cardHtml += `
                <div class="mb-3">
                  <small class="text-muted">Update needed:</small>
                  <div class="update-reason">${device.updateReason}</div>
                </div>`;
          }

          cardHtml += `
                <div class="mb-3">
                  <small class="text-muted">Location:</small>
                  <div>${device.location || "Unknown"}</div>
                </div>
                <div>
                  <small class="text-muted">Last Deployed:</small>
                  <div><strong>${device.last_deployed || "Never"}</strong></div>
                </div>
              </div>
            </div>
          `;

          col.innerHTML = cardHtml;
          deviceCardsContainer.appendChild(col);
        });
      }

      // Create status chart
      function createStatusChart(statusCounts) {
        const ctx = document.getElementById("status-chart").getContext("2d");
        new Chart(ctx, {
          type: "doughnut",
          data: {
            labels: Object.keys(statusCounts),
            datasets: [
              {
                data: Object.values(statusCounts),
                backgroundColor: [
                  "rgba(46, 204, 113, 0.8)", // Up to date - green
                  "rgba(155, 89, 182, 0.8)", // Patch available - purple
                  "rgba(243, 156, 18, 0.8)", // Needs update - orange
                  "rgba(231, 76, 60, 0.8)", // Unknown - red
                ],
                borderColor: [
                  "rgba(46, 204, 113, 1)",
                  "rgba(155, 89, 182, 1)",
                  "rgba(243, 156, 18, 1)",
                  "rgba(231, 76, 60, 1)",
                ],
                borderWidth: 1,
              },
            ],
          },
          options: {
            responsive: true,
            plugins: {
              legend: {
                position: "bottom",
              },
            },
          },
        });
      }

      // Create original timeline (for backward compatibility)
      function createOriginalTimeline(devices) {
        const timeline = document.querySelector(".timeline");
        if (timeline) {
          // Get deployments with actual dates
          const deployments = devices
            .filter(
              (device) =>
                device.last_deployed && device.last_deployed !== "Never"
            )
            .map((device) => ({
              device: device.name,
              date: device.last_deployed,
              version: device.template_version || device.version,
              components: device.components,
            }))
            .sort((a, b) => new Date(a.date) - new Date(b.date));

          // Clear timeline
          timeline.innerHTML = "";

          // Create timeline entries
          deployments.forEach((deployment, index) => {
            const isLeft = index % 2 === 0;
            const container = document.createElement("div");
            container.className = `timeline-container ${
              isLeft ? "left" : "right"
            }`;

            container.innerHTML = `
              <div class="timeline-content">
                <h5>${deployment.device}</h5>
                <p class="timeline-date">${deployment.date}</p>
                <p>Deployed version <span class="version-tag">${
                  deployment.version || "Unknown"
                }</span></p>
                ${
                  deployment.components
                    ? `
                <div class="mt-2">
                    ${generateComponentTags(deployment.components)}
                </div>`
                    : ""
                }
              </div>
            `;

            timeline.appendChild(container);
          });

          // If no deployments
          if (deployments.length === 0) {
            timeline.innerHTML =
              '<div class="text-center py-4">No deployment history available</div>';
          }
        }
      }

      // Render timeline of events
      function renderTimeline(events) {
        const timelineContainer = document.getElementById("timeline-container");
        if (!timelineContainer || !events || events.length === 0) {
          timelineContainer.innerHTML =
            '<div class="text-center py-4">No deployment history available</div>';
          return;
        }

        timelineContainer.innerHTML = "";

        // Group events by month/year for a cleaner timeline
        const groupedEvents = groupEventsByMonth(events);

        // Create timeline elements
        groupedEvents.forEach((group) => {
          const monthSection = document.createElement("div");
          monthSection.className = "timeline-month card mb-4";

          const monthHeader = document.createElement("h3");
          monthHeader.className = "card-header bg-primary text-white";
          monthHeader.innerHTML = `<i class="bi bi-calendar-month"></i> ${group.month}`;
          monthSection.appendChild(monthHeader);

          const eventsList = document.createElement("div");
          eventsList.className = "timeline-events card-body p-0";

          // Group by date
          const eventsByDate = {};
          group.events.forEach((event) => {
            const date = new Date(event.date).toLocaleDateString();
            if (!eventsByDate[date]) {
              eventsByDate[date] = [];
            }
            eventsByDate[date].push(event);
          });

          // Create date groups
          Object.keys(eventsByDate).forEach((date) => {
            const dateGroup = document.createElement("div");
            dateGroup.className = "date-group";

            const dateHeader = document.createElement("h5");
            dateHeader.className =
              "date-header bg-light p-2 m-0 border-top border-bottom";
            dateHeader.innerHTML = `<i class="bi bi-calendar-date"></i> ${date}`;
            dateGroup.appendChild(dateHeader);

            const dateEvents = document.createElement("ul");
            dateEvents.className = "list-group list-group-flush";

            eventsByDate[date].forEach((event) => {
              const eventItem = document.createElement("li");
              eventItem.className = `list-group-item event-${event.event_type} border-0`;

              // Fix version display - Remove 'v' prefix if it already exists in the version
              const versionText = event.version || "";
              const displayVersion = versionText.startsWith("v")
                ? versionText
                : `v${versionText}`;

              const deviceName = event.device_name || event.device;
              const location = event.location
                ? `<span class="text-muted"><i class="bi bi-geo-alt"></i> ${event.location}</span>`
                : "";

              // Use different styles based on event type
              let eventIcon = "bi-arrow-repeat";
              let eventClass = "text-primary";

              if (event.event_type === "initial_deployment") {
                eventIcon = "bi-plus-circle";
                eventClass = "text-success";
              } else if (event.event_type === "update_deployment") {
                eventIcon = "bi-arrow-up-circle";
                eventClass = "text-primary";
              } else if (event.event_type === "previous_deployment") {
                eventIcon = "bi-clock-history";
                eventClass = "text-secondary";
              } else if (event.event_type === "deployment") {
                eventIcon = "bi-check-circle";
                eventClass = "text-success";
              }

              eventItem.innerHTML = `
          <div class="d-flex align-items-center">
            <div class="me-3">
              <i class="bi ${eventIcon} ${eventClass}" style="font-size: 1.5rem;"></i>
            </div>
            <div class="flex-grow-1">
              <div class="fw-bold">${deviceName}</div>
              <div>${event.description} 
                <span class="badge bg-info">${displayVersion}</span>
              </div>
              <div class="mt-1">${location}</div>
            </div>
          </div>
        `;

              dateEvents.appendChild(eventItem);
            });

            dateGroup.appendChild(dateEvents);
            eventsList.appendChild(dateGroup);
          });

          monthSection.appendChild(eventsList);
          timelineContainer.appendChild(monthSection);
        });
      }

      // Group events by month/year
      function groupEventsByMonth(events) {
        const groups = {};

        events.forEach((event) => {
          const date = new Date(event.date);
          const monthYear = date.toLocaleDateString("en-US", {
            month: "long",
            year: "numeric",
          });

          if (!groups[monthYear]) {
            groups[monthYear] = {
              month: monthYear,
              timestamp: date.getTime(), // For sorting
              events: [],
            };
          }

          groups[monthYear].events.push(event);
        });

        // Sort events within each group by date (newest first)
        Object.values(groups).forEach((group) => {
          group.events.sort((a, b) => new Date(b.date) - new Date(a.date));
        });

        // Convert to array and sort by date (newest first)
        return Object.values(groups).sort((a, b) => b.timestamp - a.timestamp);
      }

      function resetFilterBadges(greyOut = false) {
        const filterBadges = document.querySelectorAll(".filter-badge");
        filterBadges.forEach((b) => {
          b.className = "filter-badge badge";
          if (greyOut) {
            b.classList.add("bg-secondary");
          } else {
            const filterClass = b.dataset.filter;
            if (filterClass === "up-to-date") {
              b.classList.add("bg-success");
            } else if (filterClass === "patch-available") {
              b.classList.add("bg-info");
            } else if (filterClass === "needs-update") {
              b.classList.add("bg-warning", "text-dark");
            } else if (filterClass === "unknown") {
              b.classList.add("bg-danger");
            }

            // Show all devices
            const deviceItems = document.querySelectorAll(".device-item");
            deviceItems.forEach((item) => {
              item.style.display = "block";
            });

            // Show all devices in list view too
            document.querySelectorAll(".device-list-item").forEach((item) => {
              item.style.display = "";
            });
          }
        });
      }

      function filterDevicesByStatus(statusClass) {
        // Filter card view
        const deviceItems = document.querySelectorAll(".device-item");
        deviceItems.forEach((item) => {
          if (item.dataset.status === statusClass) {
            item.style.display = "block";
          } else {
            item.style.display = "none";
          }
        });

        // Filter list view
        const listItems = document.querySelectorAll(".device-list-item");
        listItems.forEach((item) => {
          if (item.classList.contains(statusClass)) {
            item.style.display = "";
          } else {
            item.style.display = "none";
          }
        });
      }

      function filterDevicesByComponent(component) {
        // Filter card view
        const deviceItems = document.querySelectorAll(".device-item");
        deviceItems.forEach((item) => {
          if (item.dataset[component]) {
            item.style.display = "block";
          } else {
            item.style.display = "none";
          }
        });

        // Filter list view
        const listItems = document.querySelectorAll(".device-list-item");
        listItems.forEach((item) => {
          // Use data attribute from parent card to determine if it has the component
          const deviceName = item.querySelector(".col-md-3").textContent;
          const matchingCard = Array.from(deviceItems).find((card) =>
            card.querySelector(".card-header").textContent.includes(deviceName)
          );

          if (matchingCard && matchingCard.dataset[component]) {
            item.style.display = "";
          } else {
            item.style.display = "none";
          }
        });
      }

      function filterDevices() {
        const searchTerm = document
          .getElementById("device-search")
          .value.toLowerCase();

        // Filter card view
        const deviceItems = document.querySelectorAll(".device-item");
        deviceItems.forEach((item) => {
          const deviceName = item
            .querySelector(".card-header")
            .textContent.toLowerCase();
          const deviceLocation = item
            .querySelector(".card-body")
            .textContent.toLowerCase();

          if (
            deviceName.includes(searchTerm) ||
            deviceLocation.includes(searchTerm)
          ) {
            item.style.display = "block";
          } else {
            item.style.display = "none";
          }
        });

        // Filter list view
        const listItems = document.querySelectorAll(".device-list-item");
        listItems.forEach((item) => {
          const text = item.textContent.toLowerCase();

          if (text.includes(searchTerm)) {
            item.style.display = "";
          } else {
            item.style.display = "none";
          }
        });
      }

      // Set up all event listeners
      function setupEventListeners(data) {
        // Set up search functionality
        const searchInput = document.getElementById("device-search");
        searchInput.addEventListener("input", filterDevices);

        // Set up filter badges
        const filterBadges = document.querySelectorAll(".filter-badge");
        filterBadges.forEach((badge) => {
          badge.addEventListener("click", () => {
            if (badge.classList.contains("bg-secondary")) {
              // Reset the badge to its original color
              resetFilterBadges();
            } else {
              // Set all badges to secondary color first
              resetFilterBadges(true);

              // Restore this badge to its original color
              const filterClass = badge.dataset.filter;
              if (filterClass === "up-to-date") {
                badge.classList.remove("bg-secondary");
                badge.classList.add("bg-success");
              } else if (filterClass === "patch-available") {
                badge.classList.remove("bg-secondary");
                badge.classList.add("bg-info");
              } else if (filterClass === "needs-update") {
                badge.classList.remove("bg-secondary");
                badge.classList.add("bg-warning", "text-dark");
              } else if (filterClass === "unknown") {
                badge.classList.remove("bg-secondary");
                badge.classList.add("bg-danger");
              }

              // Filter the devices
              filterDevicesByStatus(filterClass);
            }
          });
        });

        // Set up view toggle buttons
        document
          .getElementById("card-view-btn")
          .addEventListener("click", () => {
            document.getElementById("device-cards").style.display = "flex";
            document.getElementById("device-list").style.display = "none";
            document.getElementById("card-view-btn").classList.add("active");
            document.getElementById("list-view-btn").classList.remove("active");
          });

        document
          .getElementById("list-view-btn")
          .addEventListener("click", () => {
            document.getElementById("device-cards").style.display = "none";
            document.getElementById("device-list").style.display = "block";
            document.getElementById("card-view-btn").classList.remove("active");
            document.getElementById("list-view-btn").classList.add("active");
          });

        // Set up sort buttons
        document
          .getElementById("sort-by-date")
          .addEventListener("click", () => {
            renderDeviceList(data.devices, "date");
          });

        document
          .getElementById("sort-by-name")
          .addEventListener("click", () => {
            renderDeviceList(data.devices, "name");
          });

        document
          .getElementById("sort-by-status")
          .addEventListener("click", () => {
            renderDeviceList(data.devices, "status");
          });

        document
          .getElementById("sort-by-location")
          .addEventListener("click", () => {
            renderDeviceList(data.devices, "location");
          });
      }
    </script>
  </body>
</html>
